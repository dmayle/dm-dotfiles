" As long as this is in a user vimrc, it has no effect, but we never want old
" vi-mode in any case.
set nocompatible

" ##############################################################################
" ****** PATHOGEN ******
" This VIMRC uses Pathogen to manage per-directory plugins.  In order for
" Pathogen to work properly, it must be loaded before filetype and syntax
" plugins, so this block will turn that off, enable Pathogen, and re-enable
" filetype and syntax.
" ##############################################################################

" Make sure pathogen ftplugins are properly installed by disabling then
" re-enabling file type plugins.
filetype off

" Enable auto-loading of per-directory plugins in ~/.vim/bundle
call pathogen#infect()
" Do the same for machine local viles in ~/.vim_local/bundle
call pathogen#infect('~/.vim_local/bundle')
" Generate helptags for all of the above plugins
call pathogen#helptags()

" Set the basics and start with the shared config.
filetype plugin indent on
syntax on

" ##############################################################################
" ****** USER PREFS ******
" Now it's time for our user preferences.
" ##############################################################################

" Make sure MacVim uses our pretty font with Powerline characters
set guifont=Ubuntu\ Mono\ for\ Powerline:h13

" Prevent file mode lines from changing VIM settings (can cause security
" exploits anyway).
set modelines=0

" Default to regex search replace affecting all versions of a string within
" the same line.
set gdefault

" Show visual characters for tabs and EOL (if this is enabled, then the line
" two below this comment looks lite it has the same character twice.)
set list
set listchars=tab:▸\ ,eol:¬,trail:☐
autocmd FileType go setlocal listchars=tab:\ \ ,eol:¬,trail:☐

" Make sure there is always at least 3 lines of context on either side of the
" cursor (above and below).
set scrolloff=3

" I list these format options :help fo-table
set formatoptions+=rcoqnl1

" Autofill to the longest shared substring, and always show the menu, even if
" there is only one match.
set completeopt=longest,menuone

" In console mode, <C-SPACE> is not sent by the term program, for some reason it
" sends <C-@> instead. I use <C-SPACE> for omni-completion.
if has("gui_running")
  inoremap <C-SPACE> <C-X><C-O><C-P>
else
  inoremap <C-@> <C-X><C-O><C-P>
endif

" If w! doesn't work (because you don't have permessions), use w!! to save
cnoremap <silent> w!! :exec ":echo ':w!!'"<CR>:%!sudo tee > /dev/null %

" Prevent me from ever using my arrow keys again:
nnoremap <up> <nop>
inoremap <up> <nop>
nnoremap <down> <nop>
inoremap <down> <nop>
nnoremap <left> <nop>
inoremap <left> <nop>
nnoremap <right> <nop>
inoremap <right> <nop>

" Turn on 16-color display.
" In 8-color mode, VIM supports 16 foreground colors (8 dark, 8 light with or
" without 'bold') and 8 dark background colors.  You can even get 16-background
" colors (8 dark via 'NONE' or 'reverse', 8 light via 'reverse'), but then you
" are limited to 8 bright foreground colors (with or without 'bold').  There is
" no way to specify bright background colors with dark foreground colors.
" (Attempting to do so will either end up with both bright, or one bright with
" one dark.) Setting 16-color mode allows VIM to use any of the 16 foreground
" colors with any of the 16 background colors
if has("terminfo")
  let &t_Co=16
  let &t_AB="\<Esc>[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm"
  let &t_AF="\<Esc>[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm"
else
  let &t_Co=16
  let &t_Sf="\<Esc>[3%dm"
  let &t_Sb="\<Esc>[4%dm"
endif

" Use a colorscheme that's a bit brighter than the default. Force the 16 color
" version of Solarized.
set background=dark
colorscheme solarized

" Set find-as-you-type searching
set incsearch

" I prefer vertical splits for my diffs
set diffopt+=vertical

" Case insensitive searching
set ignorecase

" Use case-sensitive searching if I specify case in the search string
set smartcase

" Highlight search matches in the window.
set hlsearch

" Show line numbers relative to the current cursor line to make repeated
" commands easier to compose. We only do this while in the buffer.  When focused
" in another buffer, we use standard numbering.
autocmd BufEnter * setlocal relativenumber
autocmd BufLeave * setlocal number

" With relative numbers, I never have more than 3 digits of line history on the
" screen at once
set numberwidth=4

" Enable mouse support in text terminals (using smarter mouse protocol, xterm2)
set mouse=a
set ttymouse=xterm2

" Store 200 lines of command history
set history=200

" Keep unsaved files open with their changes
set hidden

" As far as I can tell, all this does is add display a length when performing
" a visual selection.
set showcmd

" Enable syntax base folding
"set foldmethod=syntax

" Close all folds by default
"set foldlevel=0

" Try to open existing instances of a buffer from other windows or tabs before
" duplicating
set switchbuf=usetab

" Spellcheck the languages I work in.
set spelllang=en_us,fr

" Status Line - This will be disabled by VIM Powerline, but it's my preferred
" vanilla status line.
set statusline=%F%m%r%h%w\ [TYPE=%Y]\ %=\ %-(%{fugitive#statusline()}\ [POS=%04l,%04v][%p%%]\ [LEN=%L]%)
"<PATH><MODIFIED?><READONLY?><HELP?><PREVIEW?> [TYPE=<FILETYPE>]  <- LEFT
"<GIT> [POS=line,column][XX%] [LEN=X Lines]                       <- RIGHT

" Always turn on status line
set laststatus=2

" By default, I don't limit the line length of my files.  I override this for
" individual file types below.
set textwidth=0

" Spell coloring
hi SpellBad term=reverse ctermfg=white ctermbg=darkred guifg=#ffffff guibg=#7f0000 gui=undercurl

" make backspace "more powerful" (Allow backspace to 1# delete the autoindent,
" 2# delete back up the previous line, and 3# delete characters from before
" the character where insertion started.)
set backspace=indent,eol,start

" makes tabs insert "indents" at the beginning of the line
set smarttab

" reasonable defaults for indentation
set autoindent nocindent nosmartindent

" informs sh syntax that /bin/sh is actually bash
let is_bash=1

" I don't like beeping
set visualbell

" Keep a horizontal line highlighting the position of the cursor
set cursorline

" Set up wildmenu and wildmode!
set wildmenu
set wildmode=list:longest

" ##############################################################################
" ****** PERSONAL LEADER SHORTCUTS ******
" ##############################################################################

" Shortcut to toggle between a screen copy mode (no line numbers or highlighted
" special characters) and my normal handling.
nmap <silent> <leader>sc :if &relativenumber <Bar>
  \set norelativenumber nolist <Bar>
    \else <Bar>
  \set relativenumber list <Bar>
    \endif<CR>

" Jump to the first line (if any) of the file longer than textwidth.
nmap <silent> <leader><space> :call search("^.\\{" . (&textwidth ? &textwidth + 1 : 9999) . "\\}")<CR>

" Delete the current buffer, and jump to a list of buffers
nmap <silent> <leader>bd :BufExplorer<cr>d

" ##############################################################################
" ****** PLUGIN SPECIFIC HANDLING ******
" ##############################################################################
" %%%%% Tagbar %%%%%
"
" Toggle the tagbar plugin
nmap <silent> <leader>t :TagbarToggle<CR>

" %%%%% a.vim %%%%%
"
" Shortcut for switching between a source file and it's corresponding header
nmap <leader>a :A<CR>

" %%%%% DelimitMate %%%%%
"
" When hitting enter between an empty delimiter pair, push it down an extra
" line to leave space for what is being typed.
let delimitMate_expand_cr = 1

" VIM has a setline() bug that breaks undo when hitting <CR> from insert mode.
" delimitMate defaults to disabling CR expansion in comment regions, which
" triggers this bug. Since I don't use the feature, I explicitly disable it here
" to ensure undo fidelity.  Bug detailed at:
" https://groups.google.com/forum/?fromgroups=#!topic/vim_use/yRcEE2eO8TQ
" https://github.com/Raimondi/delimitMate/issues/114
let delimitMate_excluded_regions_enabled = 0

" %%%%% Powerline %%%%%
"
" Configuration for Powerline, using a patched font and the 16-color Solarized
" colorscheme.
" I re-enable it.
let g:Powerline_symbols = 'fancy'
let g:Powerline_colorscheme='solarized16'

" Tell Powerline to display an indicator when there is trailing whitespace in
" the current buffer
call Pl#Theme#InsertSegment('ws_marker', 'after', 'lineinfo')

" %%%%% IndentGuides %%%%%
"
" Use IndentGuides coloring that makes sense in Solarized.  Force 16-color for
" now, since that's what I use, but switch to g:base00, e.g. when Solarized is
" updated to export the color names.
let g:indent_guides_auto_colors = 0
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  cterm=NONE
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven cterm=NONE ctermbg=0 guibg=Grey40

" %%%%% GUndo %%%%%
"
" Add a handy mapping for bringing up the undo tree.
nnoremap <F5> :GundoToggle<CR>

" %%%%% Fugitive %%%%%
"
" Fixup diff handling for Fugitive buffers.
autocmd BufNewFile,BufRead fugitive://* set bufhidden=delete

" ##############################################################################
" ****** FILE SPECIFIC HANDLING ******
" ##############################################################################

" Turn on all conditional python highlighting
let python_highlight_all = 1

" Set up default spacing and tabs for a few filetypes.  I've left off Go, since
" the filetype plugin handles it fore me.
autocmd FileType mail,text,python,gitcommit,cpp,java,sh setlocal tabstop=8 shiftwidth=2 expandtab

" Standard GO tab settings (tabs, not spaces
autocmd FileType go setlocal tabstop=2 shiftwidth=2 noexpandtab

" Turn on spellchecking in these file types.
autocmd FileType mail,text,python,gitcommit,cpp setlocal spell

"Teach VIM about spitfire templates
autocmd BufNewFile,BufRead *.spt set filetype=cheetah

"Teach VIM about go source
autocmd BufNewFile,BufRead *.go set filetype=go

" This trifecta allows us to create a default IndentGuides setting, and override
" it per-filetype.  IndentGuides settings apply globally, and not per-buffer, so
" any changes must be triggered with BufEnter.  In this case, we tell VIM to
" retrigger FileType commands each time you change the buffer, so that
" IndentGuides will be updated for each buffer you work on.
autocmd BufEnter * filetype detect
autocmd FileType * IndentGuidesDisable
autocmd FileType python,html,cheetah,java,sh,vim,cpp,go IndentGuidesEnable

" Ensure that we autowrap git commits to 72 characters, per tpope's guidelines
" for good git comments.
autocmd FileType gitcommit setlocal textwidth=72

" I use 80-column lines in mail, plain text, C++ files, and my vimrc.
autocmd FileType mail,text,vim,cpp setlocal textwidth=80

" I use 100-column lines in Java files
autocmd FileType java setlocal textwidth=100

" Update our tags file after writing to a source file.
"au BufWritePost .m,.py,.c,.cpp,*.h,.js silent! !ctags -R &

" Use the standard tags file, as will as the iPhone tags file if present
"set tags=~/.vim/iPhone.tags;tags;/

" ##############################################################################
" ****** ENABLE INDENTATION BASED MOVEMENT FOR PYTHON ******
" http://vim.wikia.com/wiki/Move_to_next/previous_line_with_same_indentation
" ##############################################################################

" Jump to the next or previous line that has the same level or a lower
" level of indentation than the current line.
"
" exclusive (bool): true: Motion is exclusive
" false: Motion is inclusive
" fwd (bool): true: Go to next line
" false: Go to previous line
" lowerlevel (bool): true: Go to line with lower indentation level
" false: Go to line with the same indentation level
" skipblanks (bool): true: Skip blank lines
" false: Don't skip blank lines
function! NextIndent(exclusive, fwd, lowerlevel, skipblanks)
  let line = line('.')
  let column = col('.')
  let lastline = line('$')
  let indent = indent(line)
  let stepvalue = a:fwd ? 1 : -1
  while (line > 0 && line <= lastline)
    let line = line + stepvalue
    if ( ! a:lowerlevel && indent(line) == indent ||
          \ a:lowerlevel && indent(line) < indent)
      if (! a:skipblanks || strlen(getline(line)) > 0)
        if (a:exclusive)
          let line = line - stepvalue
        endif
        exe line
        exe "normal " column . "|"
        return
      endif
    endif
  endwhile
endfunction

" Moving back and forth between lines of same or lower indentation.
" nnoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
" nnoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
" nnoremap <silent> [L :call NextIndent(0, 0, 1, 1)<CR>
" nnoremap <silent> ]L :call NextIndent(0, 1, 1, 1)<CR>
" vnoremap <silent> [l <Esc>:call NextIndent(0, 0, 0, 1)<CR>m'gv''
" vnoremap <silent> ]l <Esc>:call NextIndent(0, 1, 0, 1)<CR>m'gv''
" vnoremap <silent> [L <Esc>:call NextIndent(0, 0, 1, 1)<CR>m'gv''
" vnoremap <silent> ]L <Esc>:call NextIndent(0, 1, 1, 1)<CR>m'gv''
" onoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
" onoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
" onoremap <silent> [L :call NextIndent(1, 0, 1, 1)<CR>
" onoremap <silent> ]L :call NextIndent(1, 1, 1, 1)<CR>

" ##############################################################################
" ****** Toggle version of fugitive diff ******
" ##############################################################################
function GDiffToggle()
  if exists("s:gdifftogglebuff")
    " There is an existing diff buffer, so we are turning off the diff.  If
    " we're in the diff window, then we delete it and move to the source window.
    " Otherwise, we delete the diff window, turn off diffmode for the source
    " window, but make sure that we leave the cursor in the same window.
    " turn off diff
    let l:curwin = winnr()
    exec "bd " . s:gdifftogglebuff
    unlet s:gdifftogglebuff
    diffoff
    return
  endif
  exec "Gdiff"
  " Get the diff buffer by getting the buffer from the last accessed window.
  let s:gdifftogglebuff = winbufnr(winnr('#'))
  " Keep track of the source buffer as well.
  let s:gdifftoggleorig = winbufnr(0)
endfunction

nmap <silent> <unique> <Leader>gt :call GDiffToggle()<CR>

" ##############################################################################
" ****** SAVING FOLD STATE ******
" ##############################################################################

" Keep fold state
"autocmd BufWinLeave * call KeepFoldState("enter")
"autocmd BufWinEnter * call KeepFoldState("leave")

"function! KeepFoldState(leaveEnter)
"  if a:leaveEnter == 'enter'
"    if bufname("%") != ""
"      mkview
"    endif
"  endif
"  if a:leaveEnter == 'leave'
"    if bufname("%") != ""
"      silent loadview
"    endif
"  endif
"endfunction

" ##############################################################################
" ****** COLUMN LAYOUT INDICATOR ******
" ##############################################################################

" Enable VIM 7.3+ native column indicator support if possible
if exists("+colorcolumn")
  " Use the textwidth value as the column length indicator
  set colorcolumn=+1,+21,+41
else
  " No native support, I can't stand using overlength
endif

" ##############################################################################
" ****** BACKUP FILES ******
" We don't want to clutter up our source control directories with vim swap and
" backup files, so we collect them into a single directory.  Caveat: we use a
" single shared home directory across hosts, so we need to use a per-host
" directory to prevent collisions.
" ##############################################################################

" Name our backup directory vimbak-hostname, and our undo directory
" vimundo-hostname
let $HOST=hostname()
let $MYBACKUPDIR=$HOME . '/.vimbak-' . $HOST
let $MYUNDODIR=$HOME . '/.vimundo-' . $HOST

" Make sure the backup directory exists first.
if !isdirectory(fnameescape($MYBACKUPDIR))
  silent! execute '!mkdir -p ' . shellescape($MYBACKUPDIR)
  silent! execute '!chmod 700 ' . shellescape($MYBACKUPDIR)
endif

" Do the same for the undo directory
if !isdirectory(fnameescape($MYUNDODIR))
  silent! execute '!mkdir -p ' . shellescape($MYUNDODIR)
  silent! execute '!chmod 700 ' . shellescape($MYUNDODIR)
endif

" Set directory for swap files
set directory=$MYBACKUPDIR
" Set directory for undo files
set undodir=$MYUNDODIR
" Save the current undo state between launches
set undofile
" Set to only keep one (current) backup
set backup writebackup
" Set directory for backup files
set backupdir=$MYBACKUPDIR
" Sensible list of files we don't want backed up
set backupskip=/tmp/*,/private/tmp/*,/var/tmp/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*

" ##############################################################################
" ****** MACHINE SPECIFIC PREFERENCES ******
" Now it's time for our to run any vim code specific to this machine only
" ##############################################################################

if filereadable($HOME . "/.vimrc_local")
  source $HOME/.vimrc_local
endif

